trait Add<T> {
	type Output;
	fn add(self: &Self, other: T) Self::Output;
}

trait Sub<T> {
	type Output;
	fn sub(self: &Self, other: T) Self::Output;
}

trait SubAssign<T> {
	fn sub_assign(self: &/*mut*/ Self, other: T) Self::Output;
}

struct uint;

for uint impl Add<uint> {
	type Output = uint;
	fn add(self: &Self, other: uint) Self::Output {
		self::internal::add(self, other)
	}
}

for uint impl Sub<uint> {
	type Output = uint;
	fn sub(self: &Self, other: uint) Self::Output {
		self::internal::sub(self, other)
	}
}

for uint impl SubAssign<uint> {
	fn sub_assign(self: &/*mut*/ Self, other: uint) Self::Output {
		// sugar for `self.add(other)` that is sugar for `self::internal::sub(self, other)`
		self.* = self + other;
	}
}

extern "internal" fn add(a: uint, b: uint) uint;
extern "internal" fn sub(a: uint, b: uint) uint;
extern "internal" fn mul(a: uint, b: uint) uint;
extern "internal" fn div(a: uint, b: uint) uint;
extern "internal" fn rem(a: uint, b: uint) uint;

extern "internal" fn shl(a: uint, b: uint) uint;
extern "internal" fn shr(a: uint, b: uint) uint;

extern "internal" fn or(a: uint, b: uint) uint;
extern "internal" fn and(a: uint, b: uint) uint;
extern "internal" fn xor(a: uint, b: uint) uint;
